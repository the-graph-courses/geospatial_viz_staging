---
title: '\ '
output:
  html_document:
    number_sections: true
    toc: true
    css: !expr here::here("global/style/style.css")
    highlight: kate
    pandoc_args: --shift-heading-level-by=-1
  word_document:
    toc: true
editor_options:
  markdown:
    wrap: 100
  canonical: true
  chunk_output_type: console
---

```{r, include = FALSE, warning = FALSE, message = FALSE}
# Load packages 
if(!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse, knitr, here)

# Source functions 
source(here("global/functions/misc_functions.R"))

# knitr settings
knitr::opts_chunk$set(warning = F, message = F, class.source = "tgc-code-block", error = T)

# Source autograder script quietly 
mute(here("ch04_functions/lessons/ch04_ls04_functions_autograder.R"))
```

<!-- # Functions: technical considerations -->

## Learning objectives

1.  You will learn some important technical advices to keep in mind when writing your own functions.

## Some technical advices on functions

@ILLUSTRATE (?):

An important point when you start creating your own functions concerns the way in which the objects created in a function and those existing outside “coexist”. Although this is a complex subject, pay attention to the following useful rules:

### A function can access an external object

If we call in a function to an object that does not exist and has not been passed as an argument, we get an error.

```{r}

test <- function() {
  obj
}

test()

```

If we create this object inside our function before using it, we remove the error (as you might have already guessed).

```{r}

test <- function() {
  obj <- 2
  obj
}

test()

```

However, we **CAN** access an object that already exists in our environment inside a function at the time the function was called. As `obj` does not exist within the function (it was not passed as an argument or defined in the function body), R will look in the global environment. If R finds an object `obj`, it uses its value when calling the function.

```{r}

test <- function() {
  obj
}

obj <- 3

test()

```

### Arguments and objects created in the function take precedence

R will privilege the object created inside the function in the case where an object with the same name also exists in the global environment.

```{r}

test <- function() {
  obj <- 10
  obj
}

obj <- 3

test()

```

This same rule also applies to arguments passed to the function.

```{r}

test <- function(obj) {
  obj
}

obj <- 3

test(20)

```

### An object created in a function exists only in this function

Another important rule: an object created inside a function is not accessible outside of it. 

```{r}

test <- function() {
  new_obj <- 15
  new_obj
}

test()

new_obj

```

Here, `new_obj` exists as long as we are in the function, but it is destroyed as soon as we leave it and therefore inaccessible in our global environment.

### You cannot modify a global object in a function

An important consequence of the third rule is that it is not possible to modify an object of the global environment. (In fact, it is possible by using the operator `<<-` but this is strongly discouraged in the vast majority of cases. Use this at your own discretion and peril!) Check out this example and try to understand what happened:

@COMMENT: `message()` did not show anything in the HTML

```{r}

test <- function() {
  obj <- 10
  #paste0 is a useful function for putting together several elements for printing/labeling and so on
  print(paste0("The value of our functions is: ", obj))
}

obj <- 3

test()

obj

```

You will notice that the value of the output of the `test` function and of the `obj` are different. This happens because:

::: side-note
- We assign `obj <- 3` in the global environment, because it is not defined inside a function.
- When executing the `test` function, it encounters the instruction `obj <- 10` defined in its local environment. At this point we therefore have two distinct objects with the same name, one global with the value 3, the other local with the value 10. As the local object has priority, it is this object that is used when displaying the message (remember the rule that states that _arguments and objects created in the function take precedence_).
- Once the functions finishes its job, the `obj <- 10` defined in its local environment is destroyed. Now, only the global environment object remains. It is therefore the one that is displayed during the last call to `obj`.
- If you need to call an object defined in the global environment inside a function, it is better to define it in the local environment as an argument of the function.
:::

::: practice

So far, what have you understood about the advice when writing your own functions in R? Type T (True) or F (False) to the sentences below: 

1. If your function calls an object that does not exist in the function but exists in the global environment an error will be returned.

2. If an object exists inside the function and in the global environment, when calling the function it will be used the value in the global environment.

3. An object created inside the function is not accessible outside of it.

:::

```{r include = F}

q1 <- "F"

.check_q1()

q2 <- "F"

.check_q2()

q3 <- "T"

.check_q3()

```
```{r include = F}
.score_print()
```

## Contributors {.unlisted .unnumbered}

The following team members contributed to this lesson:

`r tgc_contributors_list(ids = c("dcpcamara", "eduardo", "lolovanco", "kendavidn"))`

## References {.unlisted .unnumbered}

Some material in this lesson was adapted from the following sources:

-   Barnier, Julien. "Introduction à R et au tidyverse." Accessed May 23, 2022. <https://juba.github.io/tidyverse>

-   Wickham, Hadley; Grolemund, Garrett. "R for Data Science." Accessed May 25, 2022. <https://r4ds.had.co.nz/>

<!-- (Chicago format. You can use https://www.citationmachine.net) -->

`r tgc_license()`
